<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#4169E1"><meta name="author" content="GuoSL"><meta name="copyright" content="GuoSL"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>蓝桥杯-网络流裸题 | 收集一杯雾</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.20/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#4169E1"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"blog.kingsdead.cn","root":"/","title":"收集一杯雾","version":"1.1.0","mode":"time","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=UA-121354150-1"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-121354150-1');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><meta name="description" content="题目：一个有向图，求1到N的最大流 输入格式: 第一行N M，表示点数与边数 接下来M行每行s、t、c。表示一条从s到t的容量为c的边 输出格式: 一个数最大流量 样例输入: 12345678910116 101 2 41 3 82 3 42 4 42 5 13 4 23 5 24 6 75 4 65 6 3  样例输出 18  数据约定: 1n&lt;&#x3D;1000 m&lt;&#x3D;10000  预备知">
<meta property="og:type" content="article">
<meta property="og:title" content="蓝桥杯-网络流裸题">
<meta property="og:url" content="http://blog.kingsdead.cn/20201010/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%BD%91%E7%BB%9C%E6%B5%81%E8%A3%B8%E9%A2%98/index.html">
<meta property="og:site_name" content="收集一杯雾">
<meta property="og:description" content="题目：一个有向图，求1到N的最大流 输入格式: 第一行N M，表示点数与边数 接下来M行每行s、t、c。表示一条从s到t的容量为c的边 输出格式: 一个数最大流量 样例输入: 12345678910116 101 2 41 3 82 3 42 4 42 5 13 4 23 5 24 6 75 4 65 6 3  样例输出 18  数据约定: 1n&lt;&#x3D;1000 m&lt;&#x3D;10000  预备知">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010135919.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010140613.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010140839.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010141311.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010143003.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010144230.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010144728.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010151731.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010153313.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010153720.png">
<meta property="og:image" content="http://qiniu.kingsdead.cn/20201010154328.png">
<meta property="article:published_time" content="2020-10-10T10:12:01.000Z">
<meta property="article:modified_time" content="2020-10-10T10:13:29.726Z">
<meta property="article:author" content="GuoSL">
<meta property="article:tag" content="收集一杯雾">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.kingsdead.cn/20201010135919.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="GuoSL"><img width="96" loading="lazy" src="http://kingsdead.cn/20201002232844.jpg" alt="GuoSL"><span class="site-author-status" title="欢迎来到我的瞎写小屋">😊</span></a><div class="site-author-name"><a href="/about/">GuoSL</a></div><a class="site-name" href="/about/site.html">收集一杯雾</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/guosiliang" title="Github" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2294053541&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=494593115" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/34182041" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2294053541@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.cnblogs.com/guosiliang/" title="Travelling" target="_blank" style="color:#000000"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-send-plane-2-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">题目：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">预备知识和注意事项：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">3.</span> <span class="toc-text">网络流的基本性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95-Ford-Fulkerson%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">最大流量算法(Ford-Fulkerson算法)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Residual-Networks-%E5%89%A9%E4%BD%99%E7%BD%91%E8%B7%AF-%E6%AE%8B%E5%B7%AE%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">Residual Networks(剩余网路,残差图)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Augmenting-Paths-%E5%A2%9E%E5%B9%BF%E8%B7%AF%E5%BE%84"><span class="toc-number">4.2.</span> <span class="toc-text">Augmenting Paths(增广路径)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">演算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">例子：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">代码:</span></a></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.kingsdead.cn/20201010/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%BD%91%E7%BB%9C%E6%B5%81%E8%A3%B8%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="GuoSL"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="收集一杯雾"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">蓝桥杯-网络流裸题</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-10-10 18:12:01" itemprop="dateCreated datePublished" datetime="2020-10-10T18:12:01+08:00">2020-10-10</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#4169E1;"><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>一个有向图，求1到N的最大流</p>
<p><strong>输入格式:</strong></p>
<p>第一行N M，表示点数与边数</p>
<p>接下来M行每行s、t、c。表示一条从s到t的容量为c的边</p>
<p><strong>输出格式:</strong></p>
<p>一个数最大流量</p>
<p><strong>样例输入:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>样例输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>数据约定:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n&lt;=<span class="number">1000</span> m&lt;=<span class="number">10000</span></span><br></pre></td></tr></table></figure>

<h2 id="预备知识和注意事项："><a href="#预备知识和注意事项：" class="headerlink" title="预备知识和注意事项："></a>预备知识和注意事项：</h2><p>考虑如下情境：</p>
<p>在某个污水处理厂的某一道程序里，有一个「进水孔」，和一个「排水孔」，中间由许多「孔径不一」的水管连接起来，因为水管的「孔径大小」会影响到「每单位时间的流量」，因此要解决的问题，就是找到每单位时间可以排放「最大流量( flow )」的「排水方法」。</p>
<p><img src="http://qiniu.kingsdead.cn/20201010135919.png" alt="image-20201010135919914" loading="lazy"></p>
<p>以图一为例，进水孔为<code>vertex(S)</code>，排水孔为<code>vertex(T)</code>，中间要经过污水处理站<code>vertex(A)</code>与<code>vertex(C)</code>边（edge）代表水管，边的权重（weight）(以下将称为capacity )表示水管的「孔径」。</p>
<p><strong>考虑两种「排水方法」的flow：</strong></p>
<ul>
<li><p>第一种分配水流的方法，每单位时间总流量为<code>20</code>：</p>
<p><img src="http://qiniu.kingsdead.cn/20201010140613.png" alt="image-20201010140613238" loading="lazy"></p>
<ul>
<li>在Path : <code>S − A − T</code>上每单位时间流了<code>5</code>单位的水；</li>
<li>在Path : <code>S − A − C − T</code>上每单位时间流了<code>10</code>单位的水(问题出在这，占去了edge(C,T)的容量)；</li>
<li>在Path : <code>S − C − T</code>上，因为edge(C,T)上只剩下「<code>5</code>单位的容量」，因此每单位时间流了<code>5</code>单位的水。</li>
</ul>
</li>
<li><p>第二种分配水流的方法，每单位时间总流量为<code>25</code>：</p>
<p><img src="http://qiniu.kingsdead.cn/20201010140839.png" alt="image-20201010140839607" loading="lazy"></p>
<ul>
<li>在Path : <code>S − A − T</code>上每单位时间流了<code>10</code>单位的水；</li>
<li>在Path : <code>S − A − C − T</code>上每单位时间流了<code>5</code>单位的水；</li>
<li>在Path : <code>S − C− T</code>上，因为edge(C,T)上刚好还有「<code>10</code>单位的容量」，因此每单位时间流了<code>10</code>单位的水；</li>
</ul>
</li>
</ul>
<p>从以上两种「排水方式」可以看得出来，解决问题的精神，就是如何有效利用水管的「孔径容量」，让最多的水可以从「进水孔」流到「排水孔」。</p>
<p>这就是在网络流（Flow Networks）上找到最大流量（ Maximum Flow ）的问题。</p>
<h2 id="网络流的基本性质"><a href="#网络流的基本性质" class="headerlink" title="网络流的基本性质"></a>网络流的基本性质</h2><p><code>Flow Networks</code>是一个带权有向图，其<code>edge(X,Y)</code>具有非负的capacity，即：<code>c(X,Y)≥0</code>，如图二(a)。我们可以利用一个矩阵存储图信息。</p>
<p><img src="http://qiniu.kingsdead.cn/20201010141311.png" alt="image-20201010141311185" loading="lazy"></p>
<ol>
<li>若不存在<code>edge(X,Y)</code>，则定义<code>c(X,Y) = 0</code></li>
<li>特别的，要区分两个<code>vertex</code>：<ol>
<li><code>source</code>：表示<code>Flow Networks</code>的流量源头，以<code>s</code>表示。</li>
<li><code>sink/termination</code>：表示<code>Flow Networks</code>的流量终点，以<code>t</code>表示。</li>
</ol>
</li>
<li>水管里的水流：<code>flow</code>，必须满足以下三个条件<code>a.容量限制 b.反对称性 c.流守恒性</code>：<ol>
<li><strong>从顶点X流向顶点Y的流 &lt;= <code>edge(X,Y)</code>的<code>capacity</code></strong><ol>
<li>以图二(b)为例，在Path : S − A − C − D − T上的edge之capacity皆大于6，因此在此路径上流入<code>6</code>单位的<code>flow</code>是可行的。最小的<code>f(X,Y) = 7</code>，所以流过的flow只要小于等于<code>7</code>即可。</li>
</ol>
</li>
<li><code>f(X,Y) = -f(Y,X)</code>，此与电子流(负电荷)与电流(正电荷)的概念雷同</li>
<li>对有向图中除了<code>source</code>与<code>sink</code>以外的顶点而言，<code>所有「流进flow」之总和 = 所有「流出flow」的总和</code>。也就是水流不会无故增加或无故减少，可视为一种守恒。</li>
</ol>
</li>
<li><strong>可行流</strong>：在容量网络中满足以下条件的网络流flow，成为可行流<ol>
<li>弧流量限制条件：<code>0 &lt;= f(u,v) &lt;= c(u,v)</code></li>
<li>平衡条件：即流入一个点的流量要等于流出这个点的流量。(<code>source</code>和<code>sink</code>除外)</li>
</ol>
</li>
</ol>
<h2 id="最大流量算法-Ford-Fulkerson算法"><a href="#最大流量算法-Ford-Fulkerson算法" class="headerlink" title="最大流量算法(Ford-Fulkerson算法)"></a>最大流量算法(Ford-Fulkerson算法)</h2><p>Ford-Fulkerson算法需要两个辅助工具</p>
<ul>
<li>Residual Networks（剩余网路，残差图）</li>
<li>Augmenting Paths（增广路径）</li>
</ul>
<h3 id="Residual-Networks-剩余网路-残差图"><a href="#Residual-Networks-剩余网路-残差图" class="headerlink" title="Residual Networks(剩余网路,残差图)"></a>Residual Networks(剩余网路,残差图)</h3><p>Residual Networks的概念为：<strong>记录Graph上之edge还有多少「剩余的容量」可以让flow流过。</strong></p>
<p><img src="http://qiniu.kingsdead.cn/20201010143003.png" alt="image-20201010143003465" loading="lazy"></p>
<p>以图三为例:</p>
<ul>
<li><p>如果在Path：<code>S - A - C - D - T</code>上所有的edge都有<code>6</code>单位的flow流过，那么这些edge(edge(S,A)、edge(A,C)、edge(C,D)、edge(D,T))可用的<code>剩余capacity</code>，都应该<code>减6</code>。例如：edge(S,A)只能在容纳<code>9-6=3</code>单位的flow，edge(C,D)只能容纳<code>7-6=1</code>单位的flow。</p>
</li>
<li><p>最关键的是，若「从vertex(A)指向vertex(C )」之<code>edge(A,C)</code>上，有<code>6</code>单位的flow流过，即<code>f(A,C)=6</code>，那么在其<code>Residual Networks</code>上，会因应产生出一条「从vertex(C ) 指向vertex(A)」的edge(C,A)，并具有6单位的residual capacity，即:<code>cf(C,A) = 6</code>。 (证明见下）</p>
</li>
<li><p>证明：这些<code>residual capacity</code>称为：<code>剩余capacity</code>以<code>cf</code>表示。</p>
<ul>
<li><p><code>cf(C,A) = c(C,A) - f(C,A) = c(C,A) + f(A,C) = 0+6 = 6</code></p>
</li>
<li><p>其物理意义：可以用<strong>重置配置水流方向</strong>来理解。</p>
<p><img src="http://qiniu.kingsdead.cn/20201010144230.png" alt="image-20201010144230200" loading="lazy"></p>
</li>
<li><p>根据上图表示，我们可以将其看成是：我们已经有了一个通过<code>6</code>个单位的流量的剩余网络，如果现在想经过Path:<code>S - C - A - B - T</code>流过<code>2</code>单位的flow。</p>
</li>
<li><p>根据上图画出的残差图为：</p>
<p><img src="http://qiniu.kingsdead.cn/20201010144728.png" alt="image-20201010144728020" loading="lazy"></p>
</li>
<li><p>在图三(a)已经有<code>6</code>单位的流从顶点A流向顶点C，现在可以从edge(A,C)上把<code>2</code>单位的flow”收回”，转而分配到edge(A,B)上，而edge(A,C)上就只剩下<code>4</code>单位的流，最后的结果如下图所示：</p>
<p><img src="http://qiniu.kingsdead.cn/20201010151731.png" alt="image-20201010151731653" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<pre><code>我们根据上图可以看出：流入`sink (或称termination)`的flow累加到8单位。</code></pre>
<ul>
<li><p>综上：</p>
<ul>
<li>若edge(X,Y)上有flow流过，即f(X,Y)，便将edge(X,Y)上的<code>Residual Capacity</code>定义为:<code>cf(X,Y) = c(X,Y) - f(X,Y)</code></li>
<li><code>c(X,Y)</code>表示原来水管孔径大小;</li>
<li><code>f(X,Y)</code>表示目前水管已经有多少容量;</li>
<li><code>cf(X,Y)</code>表示水管还能在容纳多少流量;</li>
</ul>
</li>
</ul>
<h3 id="Augmenting-Paths-增广路径"><a href="#Augmenting-Paths-增广路径" class="headerlink" title="Augmenting Paths(增广路径)"></a>Augmenting Paths(增广路径)</h3><p>在<code>Residual Networks</code>里，所有能够「从source走到termination」的路径，也就是所有能够「增加flow的path」，就称为<code>Augmenting Paths</code>。</p>
<h3 id="演算法"><a href="#演算法" class="headerlink" title="演算法"></a>演算法</h3><p>Ford-Fulkerson Algorithm (若使用BFS搜寻路径，又称为<strong>Edmonds-Karp Algorithm</strong>）的方法如下：</p>
<ol>
<li>在<code>Residual Networks</code>上寻找<code>Augmenting Paths</code><ol>
<li>若以BFS方法寻找，便能确保每次找到的<code>Augmenting Paths</code>一定经过最少的edge。(对于所有边长度相同的情况，比如地图模型，bfs第一次遇到目标点，此时就一定是从根节点到目标节点最短的路径【因为每一次所有点都是向外扩张一步，你先遇到就一定是最短】。bfs先找到的一定是最短的)。</li>
</ol>
</li>
<li>找到<code>Augmenting Paths</code>上的<code>最小Residual Capacity</code>加入总flow，在以最小<code>Residual Capacity</code>更新<code>Residual Networks</code>的edge的<code>Residual Capacity</code>。</li>
<li>重复上述步骤，知道再也没有<code>Augmenting Paths</code>为止，便能找到最大流。</li>
</ol>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p><strong>STEP-1</strong>：先用<code>flow = 0</code>对<code>Residual Capacity</code>进行初始化，如图五(a)</p>
<p><img src="http://qiniu.kingsdead.cn/20201010153313.png" alt="image-20201010153313334" loading="lazy"></p>
<p><strong>STEP-2</strong>：在<code>Residual Networks</code>上寻找<code>Augmenting Paths</code></p>
<p>在该Graph中，使用BFS寻找<code>能够从顶点S到顶点T，且edge数最少</code>的路径，PATH = <code>S - A - B - T</code>，见图五(b)。BFS有可能找到其他一条<code>S - C - D - T</code>，这里以前者为例：</p>
<p><img src="http://qiniu.kingsdead.cn/20201010153720.png" alt="image-20201010153720513" loading="lazy"></p>
<p><strong>STEP-3</strong>：找到<code>Augmenting Paths</code>上的<code>最小Residual Capacity</code>加入总flow</p>
<p><code>最小Residual Capacity</code> = 3；</p>
<p><code>flow = flow + 3;</code></p>
<p><strong>STEP-4</strong>：以<code>最小Residual Capacity</code>更新<code>Residual Networks</code>上的edge之<code>residual capacity</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cf(S,A) &#x3D; c(S,A) - f(S,A) &#x3D; 9 - 3 &#x3D; 6;</span><br><span class="line">cf(A,S) &#x3D; c(A,S) - f(A,S) &#x3D; 0 + 3 &#x3D; 3;</span><br><span class="line">cf(A,B) &#x3D; c(A,B) - f(A,B) &#x3D; 3 - 3 &#x3D; 0;</span><br><span class="line">cf(B,A) &#x3D; c(B,A) - f(B,A) &#x3D; 0 + 3 &#x3D; 3;</span><br><span class="line">cf(B,T) &#x3D; c(B,T) - f(B,T) &#x3D; 9 - 3 &#x3D; 6;</span><br><span class="line">cf(T,B) &#x3D; c(T,B) - f(T,B) &#x3D; 0 + 3 &#x3D; 3;</span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.kingsdead.cn/20201010154328.png" alt="image-20201010154328576" loading="lazy"></p>
<p>重复上述操作，对上述残差图继续寻找增广路径，直到找不到增广路径为止。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><ol>
<li><p>建立有向图Graph，并使用<code>graph[X][Y]</code>保存edge(X,Y)的权重<code>weight</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为一条边可能会出现多次</span></span><br><span class="line">	graph[vertex1][vertex2] += weight;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用BFS方法进行搜索，寻找从<code>source</code>到<code>sink</code>的路径，而且是<code>edge</code>数量最少的路径:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">BFSFindPath</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> source, <span class="keyword">int</span> sink, <span class="keyword">int</span>[] path)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//path[]是通过记录每个节点的父节点，从而记录下一条完整的路径</span></span><br><span class="line">	<span class="comment">//每次寻找都要初始化一次path</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">		path[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> vertex_num = graph.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex_num + <span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	queue.offer(source);</span><br><span class="line">	visited[source] = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(queue.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = queue.poll(); </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertex_num; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (graph[temp][i] &gt; <span class="number">0</span> &amp;&amp; visited[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">				queue.offer(i);</span><br><span class="line">				visited[i] = <span class="keyword">true</span>;</span><br><span class="line">				path[i] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> visited[sink] == <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到从BFSFindPath()找到的路径上，最小的<code>Residual capacity</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCapacity</span><span class="params">(<span class="keyword">int</span>[] path, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min = graph[path[path.length - <span class="number">1</span>]][path.length - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = path.length - <span class="number">2</span>; i != <span class="number">1</span>; i = path[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (graph[path[i]][i] &lt; min &amp;&amp; graph[path[i]][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//如果不是&gt;0则可能把没有边的也算进去。</span></span><br><span class="line">			min = graph[path[i]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>演算法的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[vertex_num + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 在Residual Networks上寻找Augmenting Path</span></span><br><span class="line"><span class="keyword">while</span>(BFSFindPath(graph, <span class="number">1</span>, vertex_num, path)) &#123;</span><br><span class="line">	<span class="comment">//如果能够找到Augmenting Path，那么就在该路径上寻找最小容量</span></span><br><span class="line">	<span class="keyword">int</span> min_capacity = minCapacity(path, graph);</span><br><span class="line">	<span class="comment">//更新最大流</span></span><br><span class="line">	max_flow += min_capacity;</span><br><span class="line">	<span class="comment">// 更新残差图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = vertex_num; i != <span class="number">1</span>; i = path[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = path[i];</span><br><span class="line">		graph[j][i] -= min_capacity;</span><br><span class="line">		graph[i][j] += min_capacity;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(max_flow);</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="comment">//第一行输入 节点个数 和 边的个数</span></span><br><span class="line">		<span class="keyword">int</span> vertex_num = sc.nextInt();</span><br><span class="line">		<span class="keyword">int</span> edge_num = sc.nextInt();</span><br><span class="line">		<span class="comment">//初始化二维数组进行存放数据</span></span><br><span class="line">		<span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[vertex_num + <span class="number">1</span>][vertex_num + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">//每一行输入进行保存数据</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge_num; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> vertex1 = sc.nextInt();</span><br><span class="line">			<span class="keyword">int</span> vertex2 = sc.nextInt();</span><br><span class="line">			<span class="keyword">int</span> weight = sc.nextInt();</span><br><span class="line">			<span class="comment">// 填充数据，形成一个有向图</span></span><br><span class="line">			buildGraph(graph, vertex1, vertex2, weight);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 声明最大流和Augmenting Path</span></span><br><span class="line">		<span class="keyword">int</span> max_flow = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[vertex_num + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 在Residual Networks上寻找Augmenting Path</span></span><br><span class="line">		<span class="keyword">while</span>(BFSFindPath(graph, <span class="number">1</span>, vertex_num, path)) &#123;</span><br><span class="line">			<span class="comment">//如果能够找到Augmenting Path，那么就在该路径上寻找最小容量</span></span><br><span class="line">			<span class="keyword">int</span> min_capacity = minCapacity(path, graph);</span><br><span class="line">			<span class="comment">//更新最大流</span></span><br><span class="line">			max_flow += min_capacity;</span><br><span class="line">			<span class="comment">// 更新残差图</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = vertex_num; i != <span class="number">1</span>; i = path[i]) &#123;</span><br><span class="line">				<span class="keyword">int</span> j = path[i];</span><br><span class="line">				graph[j][i] -= min_capacity;</span><br><span class="line">				graph[i][j] += min_capacity;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(max_flow);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCapacity</span><span class="params">(<span class="keyword">int</span>[] path, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> min = graph[path[path.length - <span class="number">1</span>]][path.length - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = path.length - <span class="number">2</span>; i != <span class="number">1</span>; i = path[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (graph[path[i]][i] &lt; min &amp;&amp; graph[path[i]][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//如果不是&gt;0则可能把没有边的也算进去。</span></span><br><span class="line">				min = graph[path[i]][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 建立有向图</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">	    <span class="comment">// 因为一条边可能会出现多次</span></span><br><span class="line">	    graph[vertex1][vertex2] += weight;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">BFSFindPath</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> source, <span class="keyword">int</span> sink, <span class="keyword">int</span>[] path)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//path[]是通过记录每个节点的父节点，从而记录下一条完整的路径</span></span><br><span class="line">		<span class="comment">//每次寻找都要初始化一次path</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">			path[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> vertex_num = graph.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertex_num + <span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		queue.offer(source);</span><br><span class="line">		visited[source] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(queue.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = queue.poll(); </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertex_num; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (graph[temp][i] &gt; <span class="number">0</span> &amp;&amp; visited[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">					queue.offer(i);</span><br><span class="line">					visited[i] = <span class="keyword">true</span>;</span><br><span class="line">					path[i] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> visited[sink] == <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. so give me money please.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="http://qiniu.kingsdead.cn/20201003185447.png"><img loading="lazy" src="http://qiniu.kingsdead.cn/20201003185447.png" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="http://qiniu.kingsdead.cn/20201003185448.png"><img loading="lazy" src="http://qiniu.kingsdead.cn/20201003185448.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="http://qiniu.kingsdead.cn/20201003185449.png"><img loading="lazy" src="http://qiniu.kingsdead.cn/20201003185449.png" alt="QQ支付" title="QQ支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>GuoSL</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://blog.kingsdead.cn/20201010/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%BD%91%E7%BB%9C%E6%B5%81%E8%A3%B8%E9%A2%98/" title="蓝桥杯-网络流裸题">http://blog.kingsdead.cn/20201010/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%BD%91%E7%BB%9C%E6%B5%81%E8%A3%B8%E9%A2%98/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/20201004/Markdown%E6%95%99%E7%A8%8B/" rel="next" title="Markdown教程"><span class="post-nav-text">Markdown教程</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">晋ICP备2020009572号</a></div><div class="copyright"><span>&copy; 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> GuoSL</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.1.0</span></div><div class="live_time"><span>本博客已经运行了</span><span id="display_live_time"></span><span class="moe-text">啦(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-10-04T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div class="footer-custom-text"><a style="display:inline-block" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="blank" title="又拍云"><img height="30" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/logo/upyun-logo.png" alt="upyun"/></a></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#4169E1" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>